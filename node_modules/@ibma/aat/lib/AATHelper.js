/******************************************************************************
 * Licensed Materials - Property of IBM
 * "Restricted Materials of IBM"
 * Â© Copyright IBM Corp. 2016 All Rights Reserved.
 *
 * Copying, redistribution and/or modification is prohibited.
 * U.S. Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 *****************************************************************************/

var zombie = require("zombie");
var request = require("request");
var fs = require("fs");
var path = require("path");
var AATReporterJSON = require("./AATReporterJSON");
var reporterJSON = new AATReporterJSON();
var AATReporterCloud = require("./AATReporterCloud");
var reporterCloud = new AATReporterCloud();
var DeepDiff = require("deep-diff");
var AATMetricsLogger = require('./log/AATMetricsLogger');

var AAT = {
    "Config": require("./AATConfigLoader")
};
var IBMa;
!(function () {
    if (AAT.Config.rulePack.indexOf("localhost") !== -1) {
        process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
    }
    // Specify if debug information should be printed or not
    AAT.DEBUG = AAT.Config.DEBUG;

    // Array that contains the list of entries that need to be compared between the actual and baseline objects only.
    // Note: This is used by the cleanComplianceObjectBeforeCompare function to filter the report based on this.
    AAT.baselineIssueList = ["ruleId", "xpath"];

    // Build a comma seperated list of all the policies selected
    var policies = AAT.Config.policies;
    if (policies && policies !== null && policies !== undefined && typeof policies !== "undefined") {
        policies = policies.join(",");
    }

    var loggerFunction = function (output) { AAT.DEBUG && console.log(output);};

    var loggerCreate = function (type) { return logger; };

    var logger = {
        debug: loggerFunction,
        info: loggerFunction,
        error: loggerFunction,
        warn: loggerFunction,
        create: loggerCreate
    };

    // Init the Metrics logger
    metricsLogger = new AATMetricsLogger("aatjs", logger, policies);

    /**
     * This function is responsible for initializing the summary object which will store all informations about the
     * scans that will occurs while karma is still running and running compliance scans.
     *
     * @return {Object} scanSummary - return the built scan summary object, which will follow the following format:
     * {
     *     "scanID": "ef3aec68-f073-4f9c-b372-421ae00bd55d",
     *     "counts": {
     *         "violation": 0,
     *         "potentialviolation": 0,
     *         "recommendation": 0,
     *         "potentialrecommendation": 0,
     *         "manual": 0
     *     },
     *     "startReport": "2016-06-06T00:52:41.603Z",
     *     "endReport": "",
     *     "toolID": "karma-ibma-v1.0.0",
     *     "policies": [
     *         "CI162_5_2_DCP070116",
     *         "CI162_5_2_DCP080115"
     *     ],
     *     "reportLevels": [
     *         "violation",
     *         "potentialviolation",
     *         "recommendation",
     *         "potentialrecommendation",
     *         "manual"
     *     ],
     *     "labels": [
     *         "Firefox",
     *         "master",
     *         "V12",
     *         "Linux"
     *     ],
     *     "pageScanSummary": {}
     * }
     *
     * @memberOf this
     */
    AAT.initializeSummary = function () {
        // Variable Decleration
        var scanSummary = {};
        var reportLevels = AAT.Config.reportLevels;

        // Initialize counts
        scanSummary.counts = {};

        // In the case that report levels are provided then populate the count object in
        // scanSummary.counts object with the levels which were provided in reportLevels
        // array.
        if (reportLevels) {

            // Iterate over the report levels and populate the pageResultsWithCount counts
            // object
            reportLevels.forEach(function (levels) {
                scanSummary.counts[levels] = 0;
            });
        }
        // Populate the scanSummary.counts object with all the levels
        else {
            scanSummary.counts = {
                "violation": 0,
                "potentialviolation": 0,
                "recommendation": 0,
                "potentialrecommendation": 0,
                "manual": 0
            };
        }

        // Add Start time when this script is loaded into browser
        // Start time will be in milliseconds elapsed since 1 January 1970 00:00:00 UTC up until now.
        scanSummary.startReport = Date.now();

        // Leave end report as empty for now
        scanSummary.endReport = '';

        // Add the toolID, policies, reportLevels, failLevels and labels from the config to the summary
        scanSummary.toolID = AAT.Config.toolID;
        scanSummary.policies = AAT.Config.policies;
        scanSummary.reportLevels = AAT.Config.reportLevels;
        scanSummary.labels = AAT.Config.label;
        scanSummary.failLevels = AAT.Config.failLevels;

        // Add scanID (UUID) to the scan summary object
        scanSummary.scanID = AAT.Config.scanID;

        // Build the paceScanSummary object which will contains all the items that were scanned and a count
        // summary for each of the scanned items.
        scanSummary.pageScanSummary = [];

        return scanSummary;
    };

    // Initialize the scanSummary object with summary information for AAT
    AAT.scanSummary = AAT.initializeSummary();

    // Initialize the global object which will store all the diff results for a scan that is run, using
    // actual and expected.
    AAT.diffResults = {};

    // Initialize the global object which will store all the scan results indexed by the label.
    AAT.scanResults = {};

    AAT.engineLoaded = false;

    function isSelenium(content) {
        return content && content.constructor && content.constructor.toString().indexOf("WebDriver") != -1;
        //        return content && content.constructor && content.constructor.name === "Driver";
    }

    /**
     * This function loads the compliance engine. 
     * @param {Function} callback - Provide callback function which will be executed once the engine is loaded
     *
     * @return N/A - This function will not return any thing, as it is full async
     */
    AAT.loadEngine = function (content, cb) {
        if (isSelenium(content)) {
            try {
                var browser = content;
                // Selenium
                var scriptStr =
                    "var cb = arguments[arguments.length - 1];" +
                    "try {" +
                    "if (typeof(Storage) !== \"undefined\" && sessionStorage.IBMa) {" +
                    "window.IBMa = sessionStorage.IBMa;" +
                    "}" +
                    "if ('undefined' === typeof(IBMa) || !IBMa.validate) {" +
                    "var script = document.createElement('script');" +
                    "script.setAttribute('type', 'text/javascript');" +
                    "script.setAttribute(\"IBMa\", \"CCE\");" +
                    "script.setAttribute('src', '" + AAT.Config.rulePack + "engine-browser.js');" +
                    "script.addEventListener('load', function() {" +
                    "cb();" +
                    "});" +
                    "var heads = document.getElementsByTagName('head');" +
                    "if (heads.length > 0) { heads[0].appendChild(script); }" +
                    "else { document.body.appendChild(script); }" +
                    "} else { cb(); }" +
                    "} catch (e) { " +
                    "cb(e);" +
                    "}";
                browser.manage().timeouts().setScriptTimeout(60000);
                browser.executeAsyncScript(scriptStr).then(function (return_success) {
                    AAT.loadLocalEngine(cb);
                }).catch(function (err) {
                    console.log(err);
                });
            } catch (e) {
                console.log(e);
            }
        } else {
            if (IBMa) {
                cb();
            } else {
                AAT.loadLocalEngine(cb);
            }
        }
    };

    AAT.loadLocalEngine = function (cb) {
        if (IBMa) {
            cb();
            return;
        }
        request.get(AAT.Config.rulePack + "engine-node.js", function (err, data) {
            if (!data) {
                console.log("Cannot read: "+AAT.Config.rulePack+"engine-node.js");
            }
            data = data.body;
            var engineDir = path.join(__dirname, "engine");
            if (!fs.existsSync(engineDir)) {
                fs.mkdirSync(engineDir);
            }
            var cacheDir = path.join(engineDir, "cache");
            if (!fs.existsSync(cacheDir)) {
                fs.mkdirSync(cacheDir);
            }
            fs.writeFile(path.join(engineDir, "engine-node.js"), data, function (err) {
                try {
                    err && console.log(err);
                    IBMa = require("./engine/engine-node");
                } catch (e) {
                    console.log(e);
                }
                cb();
            });
        });
    };
    /**
     * This function is responsible performing a scan based on the context that is provided, following are
     * the supported context type:
     *    Single node (HTMLElement)
     *    Local file path (String)
     *    URL (String)
     *    document node
     *    data stream for html content (String)
     *
     *  Future Items
     *    Multiple node (Array of HTMLElements) ---> FUTURE
     *
     * @param {(String|HTMLElement|DocumentNode)} content - Provide the context to scan, which includes the items from above.
     * @param {String} label - Provide a label for the scan that is being performed
     * @param {Function} callback - Provide callback function which will be executed once the results are extracted.
     *
     * @return N/A - This function will not return any thing, as it is full asyn so scan will be performed and the call back
     *               function which was provided will be called which will perform the verification or anything that is needed.
     *
     * PUBLIC API
     *
     * @memberOf this
     */
    AAT.getCompliance = function (content, label, callback) {
        AAT.loadEngine(content, function () {
            try {
                AAT.DEBUG && console.log("START 'AAT.getCompliance' function");

                // Variable Decleration
                var URL;

                // Since we need to handle multiple variation of possible ways to scan items, we need to handle
                // each one differently as each one requires specific actions/setup.
                // Handle the following:
                //  Single node (HTMLElement)
                //  Multiple node (Array of HTMLElements)
                //  Local file (String)
                //  URL (String)
                //  document

                function getContent(content, callback) {
                    // Handle local file and URL's
                    if (typeof content === "string") {
                        var isURLRegex = /^(ftp|http|https):\/\//;

                        if (isURLRegex.test(content)) {
                            URL = content;
                        }

                        // Since this is a string, we consider this as either URL or local file
                        // so build an iframe based on this and get the frame doc and then scan this.
                        AAT.buildIframeAndGetDoc(content, callback);

                        return;
                    }
                    else if (isSelenium(content)) {

                    }
                    // Handle Array of nodes
                    else if (content instanceof Array) {
                        // TODO: Supporting Array of nodes, possible future enhancenment
                    }
                    // Handle single node (HTMLElement)
                    else if (content.nodeType === 1) {
                        // In the case this is a node, there is nothing special that needs to be done at this time,
                        // the engine will be able to handle this. Adding this block here as we may need to add some filtering
                        // of rules or rule sets for this case depending on if a special ruleset needs to be created or not.
                        content = content;
                    }
                    // handle scanning document
                    else if (content.nodeType === 9) {
                        // In the case this is a document element, simply send the document object to the engine for now
                        // we will need to do some filtering to remove any karma related aspects, which requires to do a
                        // document clone, and then string the karma scripts that are added and then send this document
                        // to the engine.
                        // TODO: Investigate best approach to perform filtering
                        content = content;
                    }
                    callback(content);
                }

                getContent(content, function (content) {
                    // In the case that the label is null or undefined, throw an error using the karma API
                    // console.error with the message of the error.
                    if (label === null || typeof label === "undefined" || label === undefined) {

                        // Variable Decleration
                        var testcaseWhichIsMissingRequiredLabel = null;
                        var generalErrorMessage = "\n[Error] labelNotProvided: Label must be provided when calling AAT.getCompliance.";

                        // Get the caller of the AAT.getCompliance function which will be the testcase that is calling this function
                        // This way we can make it the error more descriptive and would help the user identify where the issues is.
                        // We have to build and throw an Error() object and then using the try/catch to catch this error and then extract the
                        // stack and parse it to get the 2nd element in the stack which will be the caller of this function which will be the
                        // testcase which called this function.
                        try {
                            // Throw Error() object
                            throw new Error();
                        } catch (exception) {
                            // Extract the stack trace from the error object and parse it to get the single one caller up which will be the 2nd index
                            testcaseWhichIsMissingRequiredLabel = exception.stack.split("\n")[1];

                            // Call the Karma error API, to send message to the Karma server that there was an error on the client side
                            console.error("Label was not provided at: " + testcaseWhichIsMissingRequiredLabel + generalErrorMessage);
                        }
                    }

                    // Check to make sure that the label that is provided is unique with all the other ones
                    // that we have gone through.
                    var labelUnique = AAT.isLabelUnique(label);

                    // In the case that the label is not unique
                    if (!labelUnique) {
                        // Variable Decleration dependencies/tools-rules-html/v2/a11y/test/g471/Table-DataNoSummaryARIA.html
                        var testcaseDoesNotUseUniqueLabel = null;
                        var generalErrorMessage = "\n[Error] labelNotUnique: Label provided to AAT.getCompliance should be unique across all testcases in a single karma session.";

                        // Get the caller of the AAT.getCompliance function which will be the testcase that is calling this function
                        // This way we can make it the error more descriptive and would help the user identify where the issues is.
                        // We have to build and throw an Error() object and then using the try/catch to catch this error and then extract the
                        // stack and parse it to get the 2nd element in the stack which will be the caller of this function which will be the
                        // testcase which called this function.
                        try {
                            // Throw Error() object
                            throw new Error();
                        } catch (exception) {
                            // Extract the stack trace from the error object and parse it to get the single one caller up which will be the 2nd index
                            testcaseDoesNotUseUniqueLabel = exception.stack.split("\n")[1];

                            // Call the Karma error API, to send message to the Karma server that there was an error on the client side
                            console.error("Label \"" + label + "\" provided at: " + testcaseDoesNotUseUniqueLabel + " is not unique." + generalErrorMessage);
                        }
                    }

                    // Get the Data when the scan is started
                    // Start time will be in milliseconds elapsed since 1 January 1970 00:00:00 UTC up until now.
                    var startScan = Date.now();
                    var policies = AAT.Config.policies;
                    if (isSelenium(content)) {
                        // NOTE: Engine should already be loaded
                        var browser = content;
                        // Selenium
                        var scriptStr =
                            "var cb = arguments[arguments.length - 1];" +
                            "try {" +
                            "if (typeof(Storage) !== \"undefined\") {" +
                            "sessionStorage.IBMa = window.IBMa;" +
                            "}" +
                            // Setup all the config options in the engine
                            "IBMa.GSALoader.ROOTURL = '" + AAT.Config.rulePack + "';" +
                            "IBMa.Config.includeVisibility = " + AAT.Config.checkHiddenContent + ";" +

                            // In the case DEBUG is enabled in the karma config, also enable debuging in IBMa Scan engine
                            "IBMa.Config.DEBUG = " + AAT.DEBUG + ";" +

                            // TODO: Allow to config theses options from config file
                            "IBMa.Config.includeNodes = false;" +
                            "IBMa.Config.includeBounds = true;" +
                            "IBMa.Config.includePassed = false;" +

                            // Set the Report version as v2
                            "IBMa.Config.resultsVersion = 2;" +

                            "var policies = " + JSON.stringify(policies) + ";" +

                            // The data contains structure:
                            // data: {
                            //         counts: {}
                            //         report: {
                            //                   fail: []
                            //                   numChecked:
                            //                   numTrigger:
                            //                   pass:
                            //                   ruleTime:
                            //                   totalTime:
                            //                 }
                            //       }
                            "IBMa.validate(document, policies, function (results) {" +
                            "cb(results);" +
                            "});" +
                            "} catch (e) { " +
                            "cb(e);" +
                            "}";
                        browser.manage().timeouts().setScriptTimeout(60000);
                        browser.executeAsyncScript(scriptStr).then(function (results) {
                            // If there is something to report...
                            if (results.report) {
                                // Filter the violations based on the reporLevels
                                results = AAT.filterViolations(results);

                                // Add the count object, to data a recount after the filtering of violations is done.
                                results = AAT.updateViolationCount(results);

                                // Add the violation count to global summary object
                                AAT.addToSummaryCount(results.counts);

                                // Build the report object for this scan, to follow a specific format. Refer to the
                                // function prolog for more information on the object creation.
                                results = AAT.buildReport(results, URL, label, startScan);

                                // Add the scan results to global karma result object which can be accessed when users testcase
                                // finishes, user can also access it to alter it for any reason.
                                AAT.addResultsToGlobal(results);

                                // Add URL to the result object
                                browser.getCurrentUrl().then(function (url) {

                                    results.URL = url;

                                    // Need to call a karma API to send the results of a single scan to the AAT reporter so that they can be
                                    // saved to a file by the server side reporter.
                                    AAT.sendResultsToReporter(results, "Selenium");

                                    if (AAT.Config.captureScreenshots && browser.takeScreenshot) {
                                        browser.getCurrentUrl().then(function (url) {
                                            browser.takeScreenshot().then(function (image, err) {
                                                var screenshotResult = {
                                                    image: image,
                                                    label: label,
                                                    scanID: results.scanID
                                                };

                                                AAT.sendScreenShotToReporter(screenshotResult);

                                                // Call the user provided callback function after the filtering, building report and summary count tasks
                                                // call the user callback function with results and content object (this object can be document of Iframe which was created etc...)
                                                // The content will not be exposed to the user, unless they really need it. We use this to simplfy checking for violations.
                                                callback(results, content);
                                            });
                                        });
                                    }
                                });
                            }

                            if (!AAT.Config.captureScreenshots) {
                                // Call the user provided callback function after the filtering, building report and summary count tasks
                                // call the user callback function with results and content object (this object can be document of Iframe which was created etc...)
                                // The content will not be exposed to the user, unless they really need it. We use this to simplfy checking for violations.
                                callback(results, content);
                            }
                        }).catch(function (err) {
                            console.log(err);
                        });
                    } else {
                        // Setup all the config options in the engine
                        IBMa.GSALoader.ROOTURL = AAT.Config.rulePack;
                        IBMa.Config.includeVisibility = AAT.Config.checkHiddenContent;

                        // In the case DEBUG is enabled in the karma config, also enable debuging in IBMa Scan engine
                        IBMa.Config.DEBUG = AAT.DEBUG;

                        // TODO: Allow to config theses options from config file
                        IBMa.Config.includeNodes = false;
                        IBMa.Config.includeBounds = true;
                        IBMa.Config.includePassed = false;

                        // Set the Report version as v2
                        IBMa.Config.resultsVersion = 2;

                        // The data contains structure:
                        // data: {
                        //         counts: {}
                        //         report: {
                        //                   issues: []
                        //                   numChecked:
                        //                   numTrigger:
                        //                   pass:
                        //                   ruleTime:
                        //                   totalTime:
                        //                 }
                        //       }
                        IBMa.GSALoader.useCache = false;
                        IBMa.validate(content, policies, function (results) {
                            // If there is something to report...
                            if (results.report) {
                                // Filter the violations based on the reporLevels
                                results = AAT.filterViolations(results);

                                // Add the count object, to data a recount after the filtering of violations is done.
                                results = AAT.updateViolationCount(results);

                                // Add the violation count to global summary object
                                AAT.addToSummaryCount(results.counts);

                                // Build the report object for this scan, to follow a specific format. Refer to the
                                // function prolog for more information on the object creation.
                                results = AAT.buildReport(results, URL, label, startScan);

                                // Add the scan results to global karma result object which can be accessed when users testcase
                                // finishes, user can also access it to alter it for any reason.
                                AAT.addResultsToGlobal(results);

                                // Need to call a karma API to send the results of a single scan to the AAT reporter so that they can be
                                // saved to a file by the server side reporter.
                                AAT.sendResultsToReporter(results, "Native");
                            }

                            // Call the user provided callback function after the filtering, building report and summary count tasks
                            // call the user callback function with results and content object (this object can be document of Iframe which was created etc...)
                            // The content will not be exposed to the user, unless they really need it. We use this to simplfy checking for violations.
                            callback(results, content);
                        });

                        AAT.DEBUG && console.log("END 'AAT.getCompliance' function");
                    }
                });
            } catch (e) {
                console.log(e);
            }
        });
    };

    /**
     * This function is responsible for checking if the provided label is unique or not.
     *
     * @param {String} label - Provide the label which should be checked if it exists or not
     *
     * @return {boolean} labelExists - return false if the label is not unique, otherwise return true
     *
     * PRIVATE METHOD
     *
     * @memberOf this
     */
    AAT.isLabelUnique = function (label) {
        AAT.DEBUG && console.log("START 'AAT.isLabelUnique' function");

        // Variable Decleration
        var labelExists = false;

        AAT.DEBUG && console.log("Checking if label: " + label + " is unique.");

        // Check if the label that is provided was already used or not, by simply calling the some API on the array
        // and passing it a callback function which checks if the label exists in the global paceScanSummary object.
        labelExists = AAT.scanSummary.pageScanSummary.some(function (scanSummary) {
            return scanSummary.label === label;
        });

        AAT.DEBUG && console.log("END 'AAT.isLabelUnique' function");

        return !labelExists;
    };

    /**
     * This function is responsible for sending the scan results to the karma server AAT reporter. The
     * AAT reporter is responsible for writing the results to a file. The reporter will also keep track of
     * the summary results, on the server side.
     *
     * @param {Object} results - Provide the full results object which is to be reported/saved to file.
     *                           refer to return in function "AAT.buildReport" prolog
     *
     * @return N/A
     *
     * PRIVATE METHOD
     *
     * @memberOf this
     */
    AAT.sendResultsToReporter = function (results, profile) {
        if (AAT.Config.outputFormat.indexOf("json") != -1) {
            reporterJSON.report(results);
        }
        if (AAT.Config.outputFormat.indexOf("cloud") != -1) {
            reporterCloud.report(results);
        }
        // Only perform the profiling if profiling was not disabled on purpose
        if (!AAT.Config.label || AAT.Config.label.indexOf("IBMa-Node-TeSt") === -1) {        
            // Meter the usage here
            metricsLogger.profileV2(results.summary.scanTime, profile);
        }
    };

    AAT.sendScreenShotToReporter = function (screenshotResult) {
        if (AAT.Config.outputFormat.indexOf("cloud") != -1) {
            reporterCloud.addScreenshot(screenshotResult);
        }
    };

    if (typeof(after) !== "undefined") {
        after(function(done) {
            metricsLogger.sendLogsV2(done, AAT.Config.rulePack);
        });
    } else {
        process.on('beforeExit', function(done) {
            metricsLogger.sendLogsV2(done, AAT.Config.rulePack);
        });
    }

    /**
     * This function is responsible for building the results object in a specific format which will be provided back to
     * the user to do any thing they want to do with it. (compare, print it, save to db, etc...)
     *
     * Note: This function converts it to match with the following format outlined at:
     *       https://github.ibm.com/IBMa/Tools-Karma-Plugin/wiki/Input-Output-Basline
     *
     * @param {Object} results - The results object which we need to build the report based on, following is the format the
     *                           object needs to follow:
     *  {
     *      "report": {
     *          "numChecked": 227,
     *          "numTrigger": 1,
     *          "ruleTime": 5,
     *          "totalTime": 8,
     *          "issues": [
     *              {
     *                  "severityCode": "eISHigh",
     *                  "messageCode": "rpt.g377.elemUniqueId",
     *                  "ruleId": "377",
     *                  "help": "idhi_accessibility_check_g377.html",
     *                  "msgArgs": [
     *                      "div",
     *                      "firstDiv"
     *                  ],
     *                  "xpath": "/html[1]/body[1]/div[2]/div[2]",
     *                  "snippet": "<div id=\"firstDiv\">",
     *                  "bounds": {
     *                      "left": 10,
     *                      "top": 181,
     *                      "height": 0,
     *                      "width": 1249
     *                  },
     *                  "level": "violation"
     *              }
     *          ],
     *          "docTitle": "Helo World"
     *      },
     *      "counts": {
     *          "violation": 1,
     *          "potentialviolation": 0,
     *          "recommendation": 0,
     *          "potentialrecommendation": 0,
     *          "manual": 0
     *      },
     *      "issueMessages": {
     *          "messages": {
     *              "rpt.g377.elemUniqueId": "The {0} element has the id \"{1}\" that is either empty or already in use."
     *          },
     *          "lang": "en-us"
     *      }
     *  }
     *
     * @param {String} URL - The URL which the report is being built for
     * @param {String} label - A label to identify what this report is going to be for, in the case not using URL or local files.
     * @param {String} startScan - The start time of the scan.
     *
     * @return {Object} results - return the formatted results based in the following format:
     *
     * {
     *     "scanID": "ef3aec68-f073-4f9c-b372-421ae00bd55d",
     *     "toolID": "karma-ibma-v1.0.0",
     *     "summary": {
     *         "counts": {
     *             "violation": 5,
     *             "potentialviolation": 0,
     *             "recommendation": 5,
     *             "potentialrecommendation": 0,
     *             "manual": 1
     *         },
     *         "scanTime": 80,
     *         "policies": [
     *             "CI162_5_2_DCP080115"
     *         ],
     *         "reportLevels": [
     *             "violation",
     *             "potentialviolation",
     *             "recommendation",
     *             "potentialrecommendation",
     *             "manual"
     *         ],
     *         "startScan": "2016-06-06T00:52:41.603Z"
     *     },
     *     "URL": "http://<hostname>.canlab.ibm.com:3000/doc/",
     *     "label": "unitTestContent",
     *     "screenshot": "<placeholder>",
     *     "issueMessages": {
     *         "messages": {
     *             "rpt.g377.elemUniqueId": "The {0} element has the id \"{1}\" that is either empty or already in use."
     *         },
     *         "lang": "en-us"
     *     },
     *     "reports": [
     *         {
     *             "frameIdx": "0",
     *             "frameTitle": "Frame 0",
     *             "issues": [
     *                 {
     *                     "severity": "Low",
     *                     "message": "If style sheets are ignored or unsupported, ensure that pages are still readable and usable.",
     *                     "messageCode": "rpt.g1.styleTrigger",
     *                     "ruleId": "1",
     *                     "help": "idhi_accessibility_check_g1.html",
     *                     "msgArgs": [],
     *                     "bounds": {
     *                         "left": 0,
     *                         "top": 0,
     *                         "height": 0,
     *                         "width": 0
     *                     },
     *                     "level": "manual",
     *                     "xpath": "/html[1]/head[1]/style[1]",
     *                     "snippet": "<style type=\"text/css\">"
     *                 }
     *                 ....
     *             ]
     *         },
     *         {
     *             "frameIdx": "1",
     *             "frameTitle": "Frame 1",
     *             "issues": [
     *                 {
     *                     "severity": "High",
     *                     "message": "The table element with WAI-ARIA presentation role has structural element(s) and/or attribute(s) td.",
     *                     "messageCode": "rpt.g471.tableStructure",
     *                     "ruleId": "471",
     *                     "help": "idhi_accessibility_check_g471.html",
     *                     "msgArgs": [
     *                         "table",
     *                         "td"
     *                     ],
     *                     "bounds": {
     *                         "left": 10,
     *                         "top": 990,
     *                         "height": 219,
     *                         "width": 335
     *                     },
     *                     "level": "violation",
     *                     "xpath": "/html[1]/body[1]/div[2]/table[3]",
     *                     "snippet": "<table id=\"layout_table3\" role=\"presentation\">"
     *                 }
     *                 ....
     *             ]
     *         }
     *     ]
     * }
     *
     * PRIVATE METHOD
     *
     * @memberOf this
     */
    AAT.buildReport = function (results, URL, label, startScan) {

        // Variable Decleration
        var scanTime = 0;

        // Currently karma-ibma does not support scanning multiple frames, so set frameIDx to 0.
        results.report.frameIdx = 0;

        // Currently the engine calls the frameTitle --> docTitle so we need to rename it to frameTitle, untile the change happens in the engine.
        results.report.frameTitle = results.report.docTitle;
        delete results.report.docTitle;

        // Remove all the key which are no longer needed in single report object
        delete results.report.totalTime;
        delete results.report.numChecked;
        delete results.report.numTrigger;
        delete results.report.ruleTime;

        // Add the single report object as the first object in the array of reports and then remove the single report object.
        results.reports = [results.report];
        delete results.report;

        // Build the scan summary object which will be added to the build report
        // Note: This summary is only for this single scan.
        results.summary = {
            counts: results.counts,
            scanTime: scanTime,
            policies: AAT.Config.policies,
            reportLevels: AAT.Config.reportLevels,
            startScan: startScan
        };

        // Add scanID (UUID) to the individual pages
        results.scanID = AAT.Config.scanID;

        // Add toolID to the individual pages
        results.toolID = AAT.Config.toolID;

        // Add the URL to the object it it is defined
        if (URL !== null && typeof URL !== "undefined") {
            results.URL = URL;
        }

        // Add the label to the result object, label should always be
        // defined no matter what as it is required to be provided by the user.
        results.label = label;

        // Add the screenshot base64 object to the results object
        // TODO: Find a way to actually extract the screenshot, since karma
        // allows the use of any browesr, some browser do not allow taking screenshot
        // so would have to alalyze which browser allow it and take it for only those.
        // PhantonJS, any selenium drived browser.
        //results.screenshot = "<placeholder>";

        // Clean up the results object
        delete results.counts;

        // Return the results object after rebuilding it
        return results;
    };

    /**
     * This function is responsible for indexing the results into global spaces based on label.
     *
     * @param {Object} results - Results object which will be provided to the user/wroten to the file.
     *                           Refer to AAT.buildReport function's return to figure out what the object
     *                           will look like.
     *
     * @return - N/A - Global object is updated with the results
     *
     * PRIVATE METHOD
     *
     * @memberOf this
     */
    AAT.addResultsToGlobal = function (results) {

        // Build the single page summary object to follow the following format:
        //   "label": "dependencies/tools-rules-html/v2/a11y/test/g471/Table-DataNoSummaryARIA.html",
        //   "counts": {
        //       "violation": 1,
        //       "potentialviolation": 0,
        //       "recommendation": 0,
        //       "potentialrecommendation": 0,
        //       "manual": 0
        //   }
        var pageSummaryObject = {
            label: results.label,
            counts: results.summary.counts
        };

        // Add the summary count for this scan to the pageScanSummary object which is in the global space
        // Index this by the label.
        AAT.scanSummary.pageScanSummary.push(pageSummaryObject);

        // Add the scan results to global space
        AAT.scanResults[results.label] = results;
    };

    /**
     * This function is responsible for building an iframe object with the provided URL or local file.
     *
     * @param {String} URLorLocalFile - Provide a URL or local file to scan.
     *
     * @return {Object} content - return an object which contains the iframeDoc and also the URL or
     *                               local file name.
     *
     * PRIVATE METHOD
     *
     * @memberOf this
     */
    AAT.buildIframeAndGetDoc = function (URLorLocalFileorContent, callback) {
        // Variable Decleration
        var appendIframe = false;
        var URLorLocalFileName;

        try {
            var browser = new zombie();
            browser.load(URLorLocalFileorContent, function () {
                callback(browser.document);
            });
        } catch (e) {
            console.log(e);
        }
    };

    /**
     * This function is responsible for filtering the violations so that, only the violations levels that
     * are provided in reportLevels are presented in the report.
     *
     * TODO: Possibly we can add this to the engine, so that the results are not provided by the engine
     *       when user has provided the reportLevels object.
     *
     * @param {Object} results - Provide the violation results, which follow the following format:
     *  {
     *      "report": {
     *          "numChecked": 227,
     *          "numTrigger": 1,
     *          "ruleTime": 5,
     *          "totalTime": 8,
     *          "issues": [
     *              {
     *                  "severityCode": "eISHigh",
     *                  "messageCode": "rpt.g377.elemUniqueId",
     *                  "ruleId": "377",
     *                  "help": "idhi_accessibility_check_g377.html",
     *                  "msgArgs": [
     *                      "div",
     *                      "firstDiv"
     *                  ],
     *                  "xpath": "/html[1]/body[1]/div[2]/div[2]",
     *                  "snippet": "<div id=\"firstDiv\">",
     *                  "bounds": {
     *                      "left": 10,
     *                      "top": 181,
     *                      "height": 0,
     *                      "width": 1249
     *                  },
     *                  "level": "violation"
     *              }
     *          ],
     *          "docTitle": "Helo World"
     *      },
     *      "counts": {
     *          "level.violation": 1,
     *          "level.potentialviolation": 0,
     *          "level.recommendation": 0,
     *          "level.potentialrecommendation": 0,
     *          "level.manual": 0
     *      },
     *      "issueMessages": {
     *          "messages": {
     *              "rpt.g377.elemUniqueId": "The {0} element has the id \"{1}\" that is either empty or already in use."
     *          },
     *          "lang": "en-us"
     *      }
     *  }
     *
     * @return {Object} results - return results object which only contains the violation that were requested,
     *                            follows the following format:
     *  {
     *      "report": {
     *          "numChecked": 227,
     *          "numTrigger": 1,
     *          "ruleTime": 5,
     *          "totalTime": 8,
     *          "issues": [
     *              {
     *                  "severityCode": "eISHigh",
     *                  "messageCode": "rpt.g377.elemUniqueId",
     *                  "ruleId": "377",
     *                  "help": "idhi_accessibility_check_g377.html",
     *                  "msgArgs": [
     *                      "div",
     *                      "firstDiv"
     *                  ],
     *                  "xpath": "/html[1]/body[1]/div[2]/div[2]",
     *                  "snippet": "<div id=\"firstDiv\">",
     *                  "bounds": {
     *                      "left": 10,
     *                      "top": 181,
     *                      "height": 0,
     *                      "width": 1249
     *                  },
     *                  "level": "violation"
     *              }
     *          ],
     *          "docTitle": "Helo World"
     *      },
     *      "counts": {
     *          "level.violation": 1,
     *          "level.potentialviolation": 0,
     *          "level.recommendation": 0,
     *          "level.potentialrecommendation": 0,
     *          "level.manual": 0
     *      },
     *      "issueMessages": {
     *          "messages": {
     *              "rpt.g377.elemUniqueId": "The {0} element has the id \"{1}\" that is either empty or already in use."
     *          },
     *          "lang": "en-us"
     *      }
     *  }
     *
     *  The return object is pretty much filtered failures (results.report.fail), wrapped around another object with extra frameIdx value.
     *
     * PRIVATE METHOD
     *
     * @memberOf this
     */
    AAT.filterViolations = function (results) {

        // Variable Decleration
        var reportLevels = AAT.Config.reportLevels;
        var pageReport = results.report;

        for (var iDis=0; AAT.Config.disable && iDis < AAT.Config.disable.length; ++iDis) {
            AAT.Config.disable[iDis] = ""+AAT.Config.disable[iDis]; 
        }
        // Loop over all the violations and filter them, if the violation level does not match with, what user has
        // requested to be reported. Also handle hidden at this point right now.
        // TODO: Posible to filter the results directly in the engine, to avoid the need to do all this in each of the tools.
        for (var i = 0; i < pageReport.issues.length; ++i) {
            if (AAT.Config.disable && AAT.Config.disable.indexOf(pageReport.issues[i].ruleId) != -1) {
                pageReport.issues.splice(i--, 1);
                continue;
            }

            // Remove violation which are not in the reportLevels
            if (reportLevels) {

                // Fetch the level from the results
                var reportLevel = pageReport.issues[i].level;

                // Make sure the level is actually defined before trying to perform any action on it
                if (reportLevel !== null && typeof reportLevel !== "undefined") {
                    // Remove the violation from the object if report level is not in the reportLevels array.
                    if (reportLevels.indexOf(reportLevel) === -1) {
                        pageReport.issues.splice(i--, 1);
                        continue;
                    }
                } else {
                    // In the case that level is null or not found remove this violation from the results.
                    pageReport.issues.splice(i--, 1);
                }
            }
        }

        var lvlIdx = {
            "violation": 1,
            "potentialviolation": 2,
            "recommendation": 3,
            "potentialrecommendation": 4
        };

        pageReport.issues.sort(function (a, b) {
            var aLvl = lvlIdx[a.level];
            var bLvl = lvlIdx[b.level];
            if (!aLvl) aLvl = 4;
            if (!bLvl) bLvl = 4;
            return aLvl != bLvl && aLvl - bLvl ||
                a.ruleId != b.ruleId && a.ruleId - b.ruleId ||
                a.xpath - b.xpath;
        });

        return results;
    };

    /**
     * This function is responsible for iterating over all the issue elements and updating the counts object.
     *
     * @param {Object} pageResults - Provide the page results object, in the following format:
     *  {
     *      "report": {
     *          "numChecked": 227,
     *          "numTrigger": 1,
     *          "ruleTime": 5,
     *          "totalTime": 8,
     *          "issues": [
     *              {
     *                  "severityCode": "eISHigh",
     *                  "messageCode": "rpt.g377.elemUniqueId",
     *                  "ruleId": "377",
     *                  "help": "idhi_accessibility_check_g377.html",
     *                  "msgArgs": [
     *                      "div",
     *                      "firstDiv"
     *                  ],
     *                  "xpath": "/html[1]/body[1]/div[2]/div[2]",
     *                  "snippet": "<div id=\"firstDiv\">",
     *                  "bounds": {
     *                      "left": 10,
     *                      "top": 181,
     *                      "height": 0,
     *                      "width": 1249
     *                  },
     *                  "level": "violation"
     *              }
     *          ],
     *          "docTitle": "Helo World"
     *      },
     *      "counts": {
     *          "level.violation": 1,
     *          "level.potentialviolation": 0,
     *          "level.recommendation": 0,
     *          "level.potentialrecommendation": 0,
     *          "level.manual": 0
     *      },
     *      "issueMessages": {
     *          "messages": {
     *              "rpt.g377.elemUniqueId": "The {0} element has the id \"{1}\" that is either empty or already in use."
     *          },
     *          "lang": "en-us"
     *      }
     *  }
     *  ......
     *
     * @return {Object} pageResults - return the results object with the count object updated
     *  {
     *      "report": {
     *          "numChecked": 227,
     *          "numTrigger": 1,
     *          "ruleTime": 5,
     *          "totalTime": 8,
     *          "issues": [
     *              {
     *                  "severityCode": "eISHigh",
     *                  "messageCode": "rpt.g377.elemUniqueId",
     *                  "ruleId": "377",
     *                  "help": "idhi_accessibility_check_g377.html",
     *                  "msgArgs": [
     *                      "div",
     *                      "firstDiv"
     *                  ],
     *                  "xpath": "/html[1]/body[1]/div[2]/div[2]",
     *                  "snippet": "<div id=\"firstDiv\">",
     *                  "bounds": {
     *                      "left": 10,
     *                      "top": 181,
     *                      "height": 0,
     *                      "width": 1249
     *                  },
     *                  "level": "violation"
     *              }
     *          ],
     *          "docTitle": "Helo World"
     *      },
     *      "counts": {
     *          "level.violation": 1,
     *          "level.potentialviolation": 0,
     *          "level.recommendation": 0,
     *          "level.potentialrecommendation": 0,
     *          "level.manual": 0
     *      },
     *      "issueMessages": {
     *          "messages": {
     *              "rpt.g377.elemUniqueId": "The {0} element has the id \"{1}\" that is either empty or already in use."
     *          },
     *          "lang": "en-us"
     *      }
     *  }
     *
     * PRIVATE METHOD
     *
     * @memberOf this
     */
    AAT.updateViolationCount = function (pageResults) {

        // Variable Decleration
        var reportLevels = AAT.Config.reportLevels;

        // Build violation count object which will contain the updated count based on filter which
        // which occured in filterViolations function.
        var violationCount = {};

        // In the case that report levels are provided then populate the count object in
        // violationCount object with the levels which were provided in reportLevels
        // array/
        if (reportLevels) {

            // Iterate over the report levels and populate the pageResultsWithCount counts
            // object
            reportLevels.forEach(function (levels) {
                violationCount[levels] = 0;
            });
        }
        // Populate the pageResultsWithCount counts object with all the levels
        else {
            violationCount = {
                "violation": 0,
                "potentialviolation": 0,
                "recommendation": 0,
                "potentialrecommendation": 0,
                "manual": 0
            };
        }

        // Iterate over the page results
        pageResults.report.issues.forEach(function (item) {
            if (item.level in violationCount) {
                ++violationCount[item.level];
            }
        });

        // Update the results count object with the new one which considers filtered results
        pageResults.counts = violationCount;

        return pageResults;
    };

    /**
     * This function is responsible for updating/creating the global violation summary for the engine karma run
     * for browser that it is running on. Will take the pageCount object which is part of the page object and
     * add extract the values for each of the levels and add them to the global object. This will provide an overall
     * summary of violations for all testcases run and all scans done.
     *
     * @param {Object} pageCount - Provide the page count object, in the following format:
     *
     * @return N/A - Global summary object is updated with the counts
     *
     * PRIVATE METHOD
     *
     * @memberOf this
     */
    AAT.addToSummaryCount = function (pageCount) {

        // Variable Decleration
        var AATScanSummary = AAT.scanSummary.counts || {};
        var addedToSummary = false;

        // In the case AATScanSummary is empty, simply assign pageCount to AATScanSummary
        if (Object.keys(AATScanSummary).length === 0) {

            // Set pageCount as the summary count
            AATScanSummary = pageCount;

            addedToSummary = true;
        }

        // In the case that this is not first scan, handle adding up the summary
        if (!addedToSummary) {
            // Go through the pageCount object and for each of the levels, extract the value
            // and add it to the AAT violation summary object.
            // This will keep track of an overall summary of the violations for all testscases, that
            // were run for a single karma run.
            for (var level in pageCount) {
                AATScanSummary[level] += pageCount[level];
            }
        }

        // Assign the new violation summary back to the global object
        AAT.scanSummary.counts = AATScanSummary;
    };

    /**
     * This function is responsible for comparing the scan results with baseline or checking that there are
     * no violations which fall into the failsLevels levels. In the case a baseline is found then baseline will
     * be used to perform the check, in the case no baseline is provided then we comply with only failing if
     * there is a sinble violation which falls into failLevels.
     *
     * @param {Object} actual - the actual results object provided by the user, this object should follow the
     *                          same format as outlined in the return of AAT.buildReport function.
     *
     * @return {int} - return 0 in the case actual matches baseline or no violations fall into failsLevels,
     *                 return 1 in the case actual results does not match baseline results,
     *                 return 2 in the case that there is a failure based on failLevels (this means no baseline found).
     *                 return -1 in the case that there is an exception that occured in the results object which came from the scan engine.
     *
     * PUBLIC API
     *
     * @memberOf this
     */
    AAT.assertCompliance = function (actualResults) {

        // In the case that the details object contains Error object, this means that the scan engine through an
        // exception, therefore we should not compare results just fail instead.
        if (actualResults.details instanceof Error) {
            return -1;
        }

        // Get the label directly from the results object, the same label has to match
        // the baseline object which is available in the global space.
        var label = actualResults.label;

        // Fetch the baseline object based on the label provided
        var expected = AAT.getBaseline(label);

        // In the case there are no baseline found then run a different assertion algo,
        // when there is baseline compare the baselines in the case there is no baseline then
        // check to make sure there are no violations that are listed in the fails on.
        if (expected !== null && typeof (expected) !== "undefined") {

            // Run the diff algo to get the list of differences
            var differences = AAT.diffResultsWithExpected(actualResults, expected, true);

            //console.log(JSON.stringify(differences, null, '    '));

            // In the case that there are no differences then that means it passed
            if (differences === null || typeof (differences) === "undefined") {
                return 0;
            } else {
                // In the case that there are failures add the whole diff array to
                // global space indexed by the label so that user can access it.
                AAT.diffResults[label] = differences;

                return 1;
            }
        } else {
            // In the case that there was no baseline data found compare the results based on
            // the failLevels array, which was defined by the user.
            var returnCode = AAT.compareBasedOnFailLevels(actualResults);

            // In the case there are no violations that match the fail on then return as success
            if (returnCode === 0) {
                return returnCode;
            } else {
                // In the case there are some violation that match in the fail on then return 2
                // to identify that there was a failure, and we used a 2nd method for compare.
                return 2;
            }
        }
    };

    /**
     * This function is responsible for checking if any of the issues reported have any level that falls
     * into the failsLevel array.
     *
     * @param {Object} results - Provide the scan results, object which would be in the
     *                           the same format as outlined in the return of AAT.buildReport function.
     *
     * @return {int} - return 1 in the case a single issue was found which is in the failsLevel array.
     *                 return -1 in the case that there is an exception that occured in the results object which came from the scan engine.
     *
     * PRIVATE METHOD
     *
     * @memberOf this
     */
    AAT.compareBasedOnFailLevels = function (results) {

        // In the case that the details object contains Error object, this means that the scan engine through an
        // exception, therefore we should not compare results just fail instead.
        if (results.details instanceof Error) {
            return -1;
        }

        // Variable Decleration
        var failLevels = AAT.Config.failLevels;

        // Fetch reports object
        var reports = results.reports;

        // Loop over all the reports to check if any issues fall under failLevels
        for (var i = 0; i < reports.length; ++i) {

            // Fetch issues object
            var issues = reports[i].issues;

            // Loop over all the issues to check for any level that is in failLevels
            for (var j = 0; j < issues.length; ++j) {

                // In the case current level is in the failsLevel array them fail, with out checking further
                // currently we are not saving exactly which results failed, as all the issues are going to be saved to
                // results file.
                if (failLevels.indexOf(issues[j].level.replace('level.', '')) > -1) {
                    // return 1 as there was a fialure
                    return 1;
                }
            }
        }

        // return 0 as there were no levels that fall into the failLevels
        return 0;
    };

    /**
     * This function is responsible for comparing actual with expected and returning all the differences as an array.
     *
     * @param {Object} actual - Provide the actual object to be used for compare
     * @param {Object} expected - Provide the expected object to be used for compare
     * @param {boolean} clean - Provide a boolean if both the actual and expected objects need to be cleaned
     *                          cleaning refers to converting the objects to match with a basic compliance
     *                          compare of xpath and ruleId.
     *
     * @return {Object} differences - return an array of diff objects that were found, following is the format of the object:
     * [
     *     {
     *         "kind": "E",
     *         "path": [
     *             "reports",
     *             0,
     *             "issues",
     *             10,
     *             "xpath"
     *         ],
     *         "lhs": "/html[1]/body[1]/div[2]/table[5]",
     *         "rhs": "/html[1]/body[1]/div[2]/table[5]d",
     *     },
     *     {
     *         "kind": "E",
     *         "path": [
     *             "label"
     *         ],
     *         "lhs": "Table-layoutMultiple",
     *         "rhs": "dependencies/tools-rules-html/v2/a11y/test/g471/Table-layoutMultiple.html",
     *     }
     * ]
     *
     * PUBLIC API
     *
     * @memberOf this
     */
    AAT.diffResultsWithExpected = function (actual, expected, clean) {

        // In the case clean is set to true then run the cleanComplianceObjectBeforeCompare function on
        // both the actual and expected objects passed in. This is to make sure that the objcet follow a
        // simalar structure before compareing the objects.
        if (clean) {
            // Clean actual and expected objects
            actual = AAT.cleanComplianceObjectBeforeCompare(actual);
            expected = AAT.cleanComplianceObjectBeforeCompare(expected);
        }

        // Run Deep diff function to compare the actual and expected values.
        var differences = DeepDiff.diff(actual, expected);

        // Return the results of the diff, which will include the differences between the objects
        return differences;
    };

    /**
     * This function is responsible for cleaning up the compliance baseline or actual results, based on
     * a pre-defined set of criterias, such as the following:
     *      1. No need to compare summary object
     *      2. Only need to compare the ruleId and xpath in for each of the issues
     *
     * @param {Object} objectToClean - Provide either an baseline or actual results object which would be in the
     *                                 the same format as outlined in the return of AAT.buildReport function.
     *
     * @return {Object} objectToClean - return an object that was cleaned to only contain the information that is
     *                                  needed for compare. Following is a sample of how the cleaned object will look like:
     * {
     *     "label": "unitTestContent",
     *     "reports": [
     *         {
     *             "frameIdx": "0",
     *             "frameTitle": "Frame 0",
     *             "issues": [
     *                 {
     *                     "ruleId": "1",
     *                     "xpath": "/html[1]/head[1]/style[1]"
     *                 }
     *                 ....
     *             ]
     *         },
     *         {
     *             "frameIdx": "1",
     *             "frameTitle": "Frame 1",
     *             "issues": [
     *                 {
     *                     "ruleId": "471",
     *                     "xpath": "/html[1]/body[1]/div[2]/table[3]"
     *                 }
     *                 ....
     *             ]
     *         }
     *     ]
     * }
     *
     * PRIVATE METHOD
     *
     * @memberOf this
     */
    AAT.cleanComplianceObjectBeforeCompare = function (objectToClean) {
        // Clone the object so that we do not reference the original or else it causes the original
        // results object or baseline object to get updated, which we do not want as users are allowed
        // access to the raw results object and baseline object.
        // Convert the object into string and then parse it as a JSON object which will lose its reference
        objectToClean = JSON.parse(JSON.stringify(objectToClean));

        // Remove the summary object, scanID, toolID, issueMessage
        delete objectToClean.summary;
        delete objectToClean.scanID;
        delete objectToClean.toolID;
        delete objectToClean.issueMessages;

        // Loop over all the reports to clean all the issues objects
        objectToClean.reports.forEach(function (report) {
            // Loop over all the issues and remove the keys that are not needed for the compare
            // Only leave the ruleId and xpath keys for compare.
            report.issues.forEach(function (issue) {

                // Loop over all the keys in a single issue object and remove all the
                // keys that are not needed for compare
                Object.keys(issue).forEach(function (key) {

                    // Remove all the keys which are not in the baselineIssueList
                    if (AAT.baselineIssueList.indexOf(key) === -1) {
                        delete issue[key];
                    }
                });

                // Make sure that the xpath in the case there is a [1] we replace it with ""
                // to support some browser which return it differently
                issue.xpath = issue.xpath.replace(/\[1\]/g, "");
            });

            // Once we are done with filtering out the issue object of all unnecessory object, we sort
            // the issues object to make sure that all issues are sorted by gId at least to avoid any
            // un-expected issues during a compare.
            report.issues = report.issues.sort(function (issueA, issueB) {
                return issueA.ruleId - issueB.ruleId;
            });
        });

        return objectToClean;
    };

    /**
     * This function is responsible for getting the baseline object for a label that was provided.
     *
     * @param {String} label - Provide a lable for which to get the baseline for.
     *
     * @return {Object} - return the baseline object from global space based on label provided, the object will be
     *                    in the same format as outlined in the return of AAT.buildReport function.
     *
     * PUBLIC API
     *
     * @memberOf this
     */
    AAT.getBaseline = function (label) {
        try {
            return require(path.join(path.join(process.cwd(), AAT.Config.baselineFolder), label.replace(/\//g, "_")));
        } catch (e) {
            return null;
        }
    };

    /**
     * This function is responsible for getting the diff results based on label for a scan that was already performed.
     *
     * @param {String} label - Provide a lable for which to get the diff results for.
     *
     * @return {Object} - return the diff results object from global space based on label provided, the object will be
     *                    in the same format as outlined in the return of AAT.diffResultsWithExpected function.
     *
     * PUBLIC API
     *
     * @memberOf this
     */
    AAT.getDiffResults = function (label) {
        return AAT.diffResults && AAT.diffResults[label];
    };

    /**
     * This function is responsible for printing the scan results to console. This is a temp solution until
     * the defect is fixed to allow writting the results to JSON. https://github.ibm.com/IBMa/Tools-Karma-Plugin/issues/50
     *
     * @param {Object} results - Provide the results from the scan.
     *
     * @return {String} resultsString - String representation of the results/violations.
     *
     * PUBLIC API
     *
     * @memberOf this
     */
    AAT.stringifyResults = function (results) {

        // Variable Decleration
        var resultsString = "\n";

        // Loop over the reports and build the string version of the the issues within each report
        results.reports && results.reports.forEach(function (report) {

            // Loop over all the issues and build a string representation of the issues
            report.issues.forEach(function (issue) {

                // Build string of the issues with only level, messageCode, xpath and snippet.
                resultsString += "Level: " + issue.level +
                    "\n\tMessage: " + IBMa.Config.getNLS(issue.messageCode, issue.msgArgs) +
                    "\n\tXPath: " + issue.xpath +
                    "\n\tSnippet: " + issue.snippet +
                    "\n\tHelp: " + AAT.getHelpURL(issue.help) +
                    "\n";
            });
        });

        return resultsString;
    };

    /**
     * This function is responsible for building the full help file URL using rule server.
     *
     * @param {String} helpFileName - Provide the help file name
     *
     * @return {String} helpFileName - The full help file URL
     *
     * PRIVATE METHOD
     *
     * @memberOf this
     */
    AAT.getHelpURL = function (helpFileName) {
        return AAT.Config.rulePack + "../../../doc/w3/help/en-US/" + helpFileName;
    };
})();
module.exports = AAT;