var request = require("request");
var Checker = require("./Checker");
//Checker.GSALoader.useCache = true;
//checker.Config.DEBUG=true;
//Checker.Config.includeBounds=false;
//checker.Config.includeVisibility=false;
Checker.Config.includeNodes=false;
//checker.Config.includePassed=true;

var Promise = require("promise");

var ZombieWrapper = function (aatLog, bluemixConfig, driver, params) {
    var doProfile = true;
    driver.config = params || {};
    
    if (bluemixConfig) {
        doProfile = false;
        Checker.GSALoader.ROOTURL = bluemixConfig.endpoint+"tool/c64ac3ac-07e2-409b-a5f7-b893e4ac120e/"+bluemixConfig.instanceId+"/";
    }
    if (params.pem) {
        Checker.Config.pem = params.pem;
    }

    driver.getNumFrames = function() {
        function countFrames(rootWin) { 
            var retVal = 1;
            for (var i=0; i<rootWin.frames.length; ++i) { 
                retVal += countFrames(rootWin.frames[i]); 
            } 
            return retVal; 
        } 
        return countFrames(driver.window);
    }
    
    function getFrameWinHelp(rootWin, startIdx, searchIdx) {
        if (startIdx == searchIdx)
            return rootWin;
        startIdx = startIdx+1;
        for (var i=0; i<rootWin.frames.length; ++i) {
            var result = getFrameWinHelp(rootWin.frames[i], startIdx, searchIdx);
            if (typeof result == typeof 3)
                startIdx = result;
            else return result;
        }
        return startIdx;
    }
    
    function getFrameWin(idx) {
        try {
            return getFrameWinHelp(driver.window, 0, idx);
        } catch(e) {
            console.log(e);
            return null; 
        }
    };

    var scanTimes = [];
    function profile(time) {
        scanTimes.push(time);
    }
    if (doProfile) {
        var sendLogs = function(done) {
            try {
                if (this.timeout) {
                    this.timeout(0);
                }
                if (scanTimes.length > 0) {
                    var qs = "?p=zombiejs&s=aat&res=";
                    scanTimes.forEach(function(t) {
                        qs += "OK,";
                    });
                    qs = qs.substr(0,qs.length-1);
                    qs += "&qt=";
                    scanTimes.forEach(function(t) {
                        qs += "0,";
                    });
                    qs = qs.substr(0,qs.length-1);
                    qs += "&st=";
                    scanTimes.forEach(function(t) {
                        qs += t;
                        qs += ",";
                    });
                    qs = qs.substr(0,qs.length-1);
                    qs += "&t=";
                    scanTimes.forEach(function(t) {
                        qs += "rs,";
                    });
                    qs = qs.substr(0,qs.length-1);
                    scanTimes = [];
                    request.get("http://ibmac96.austin.ibm.com/cgi-bin/log-cio/log.py"+qs, function() {
                        if (done) done();
                    });
                } else {
                    if (done) done();
                }
            } catch (e) {
                if (done) done(e);
            }
        }       
        if (typeof(after) !== "undefined") {
            after(sendLogs);
        } else {
            process.on('beforeExit', sendLogs);
        }
    }
    
    driver.getFrameTitle = function(i) {
        var doc = getFrameWin(i).document;
        if (doc == null) return null;
        return doc.title;
    }
    
    driver.getCompliance = function(iFrame, label) {
        var startTime = new Date().getTime();
        function count(pageResults) {
            var retVal = {
                "counts" : {
                },
                "reports" : pageResults
            }
            
            if (driver.config.filterMap) {
                for (var key in driver.config.filterMap) {
                    retVal.counts[key] = 0;
                }
            } else {
                retVal.counts = {
                    "level.violation" : 0,
                    "level.potentialviolation" : 0,
                    "level.recommendation" : 0,
                    "level.potentialrecommendation" : 0,
                    "level.manual" : 0
                };
            }
            
            pageResults.forEach(function(pageResult) {
                pageResult.report.forEach(function(item) {
                    if (item.level in retVal.counts) {
                        ++retVal.counts[item.level];
                    } 
                });
            });
            return retVal;        
        }
        return new Promise(function(resolve, reject) {
            var url = driver.document.location.href;
            if (typeof(iFrame) !== "undefined" && iFrame != null && iFrame >= 0) {
                getComplianceFrame(iFrame).then(function(return_success) {
                    var pageResults = [ { "frameIdx" : iFrame, "report" : return_success}];
                    var endTime = new Date().getTime();
                    profile(endTime-startTime);
                    if (aatLog) {
                        aatLog.log(pageResults, url, label, function() {
                            resolve(count(pageResults));
                        });
                    } else {
                        resolve(count(pageResults));
                    }
                },
                function(err) {
                    reject(err);
                });
            } else {
                var numFrames = driver.getNumFrames();
                var pageResults = [];
                function addFrame(idx) {
                    getComplianceFrame(idx).then(function(return_success) {
                        pageResults.push({ "frameIdx" : idx, "report" : return_success});
                        ++idx;
                        if (idx == numFrames) {
                            var endTime = new Date().getTime();
                            profile(endTime-startTime);
                            if (aatLog) {
                                aatLog.log(pageResults, url, label, function() {
                                    resolve(count(pageResults));
                                });
                            } else {
                                resolve(count(pageResults));
                            }
                        } else {
                            addFrame(idx);                        
                        }
                    },
                    function(err) {
                        reject(err);
                    });
                }
                addFrame(0);
            } 
        });
    };
    
    function getComplianceFrame(idx) {
        return new Promise(function(resolve, reject) {
            var win = getFrameWin(idx);
            var frameHidden = false;
            if (win.frameElement) {
                var cs = win.getComputedStyle(win.frameElement);
                if (cs.visibility=='hidden' || cs.display=='none') {
                    frameHidden = true;
                }
            }
            var doc = win.document;
            if (doc == null || doc.documentElement == null) {
              reject("No document");
              return;  
            } 
            Checker.validate(doc, driver.config.policies, function(data) {
                if (!data.report) {
                    reject(data);
                    return;
                }
                if (frameHidden) {
                    data.report.fail.forEach(function(item) {
                        item.visible = false; 
                    });
                }
                var return_success = data.report.fail;
                for (var i=0;i<return_success.length; ++i) {
                    if (return_success && !driver.includeHidden) {
                        if (!return_success[i].visible) {
                            return_success.splice(i--,1);
                            continue;
                        }
                    }
                    if (driver.config.filterMap) {
                        if (!(return_success[i].levelCode in driver.config.filterMap)) {
                            return_success.splice(i--,1);
                            continue;
                        }
                    }
                }
                resolve(return_success);
            });
        });
    }

    return driver;
}

module.exports = ZombieWrapper;